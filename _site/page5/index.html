<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
    
      BForever &middot; Blog
    
  </title>

  <link rel="stylesheet" href="/styles.css">
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">
  <link rel="alternate" type="application/atom+xml" title="BForever" href="/atom.xml">
</head>


  <body>

    <div class="container content">
      <header class="masthead">
        <h3 class="masthead-title">
          <a href="/" title="Home">BForever</a>
          <small>Blog</small>
        </h3>
      </header>

      <main>
        <div class="posts">
  
  <article class="post">
    <h1 class="post-title">
      <a href="/2018/07/23/%E5%9C%A8K8S%E4%B8%8A%E8%B7%91%E4%B8%80%E4%B8%AAhelloworld/">
        在k8s上跑一个helloworld
      </a>
    </h1>

    <time datetime="2018-07-23T00:00:00+08:00" class="post-date">23 Jul 2018</time>

    <h1 id="在k8s上跑一个helloworld">在K8S上跑一个helloworld</h1>
<h2 id="建立docker镜像">建立docker镜像</h2>
<p>为了方便起见，这里直接使用一个js网页作为应用，以此创建镜像</p>
<h3 id="hello-world网页">hello world网页</h3>
<p>创建server.js，输入以下代码创建helloworld网页：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var http = require('http');

var handleRequest = function(request, response) {
  console.log('Received request for URL: ' + request.url);
  response.writeHead(200);
  response.end('Hello World!');
};
var www = http.createServer(handleRequest);
www.listen(8080);
</code></pre></div></div>

<h3 id="dockerfile">Dockerfile</h3>
<p>创建Dockerfile文件，配置镜像：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FROM node:6.9.2
EXPOSE 8080
COPY server.js .
CMD node server.js
</code></pre></div></div>
<p>其中，FROM是从官方镜像库取得node的镜像，EXPOSE表示暴露本容器的8080端口，COPY将server.js加入容器，CMD为容器中执行的命令</p>

<blockquote>
  <p>更详细的Dockerfile写法见官方文档</p>
</blockquote>

<h3 id="创建镜像">创建镜像</h3>
<p>配置好Dockerfile后，就可以使用docker的build命令根据Dockerfile的内容创建一个镜像：
<code class="highlighter-rouge">docker build -t hello-node:v1 .</code>
这里注意不要遗漏最后的<code class="highlighter-rouge">.</code></p>

<h2 id="在kubernetes上以该镜像创建一个pod">在Kubernetes上以该镜像创建一个POD</h2>
<p>在K8S集群配置完毕后，执行</p>

<p><code class="highlighter-rouge">kubectl run hello-node --image=hello-node:v1 --port=8080 --image-pull-policy=Never</code></p>

<p>即可在K8S上建立一个新的运行刚刚建立的镜像的POD</p>

<p>但是此时由于POD默认不暴露在外部，因此我们无法观察到node的输出，为此需要创建一个service将该POD的端口暴露出来</p>

<h2 id="访问该pod">访问该POD</h2>
<h3 id="kubernetes-service">Kubernetes Service</h3>
<p>Service有几个种类，默认的是cluster-ip，即只能通过pod在集群内部的IP地址进行对service的访问</p>

<p>第二种是nodeport，即在每一个Node上暴露出一个端口：nodePort，外部网络可以通过（任一Node）[NodeIP]:[NodePort]访问到后端的Service。</p>

<p>第三种是loadbalancer，请求底层云平台创建一个负载均衡器，将每个Node作为后端，进行服务分发。该模式需要底层云平台（例如GCE）支持</p>

<p>最简单的就是直接开启一个默认的clusterip的service，在master上直接通过集群内部IP访问helloworld：</p>

<p><code class="highlighter-rouge">kubectl expose deployment hello-node --port=8080 --target-port=8080</code></p>

<p>其他方式比如NodePort可以通过<code class="highlighter-rouge">--type=NodePort</code>参数指定</p>

<h3 id="进行访问">进行访问</h3>
<p>在创建好service之后，就可以使用<code class="highlighter-rouge">kubectl get service</code>查看当前运行的service，其中可以看到hello-node的ClusterIP，在浏览器中访问该IP：8080即可看到hello world！</p>

  </article>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/page6">Older</a>
  
  
    <a class="pagination-item newer" href="/page4">Newer</a>
  
</div>

      </main>

      <footer class="footer">
        <small>
          &copy; <time datetime="2018-08-09T16:03:03+08:00">2018</time>. All rights reserved.
        </small>
      </footer>
    </div>

    
  </body>
</html>
